(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["phoenix_live_view"] = factory();
	else
		root["phoenix_live_view"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/phoenix_live_view.js-exposed");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../home/vagrant/.nvm/versions/node/v8.9.1/lib/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://phoenix_live_view/(webpack)/buildin/global.js?");

/***/ }),

/***/ "../deps/phoenix/priv/static/phoenix.js":
/*!**********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  return function (e) {\n    var t = {};function n(i) {\n      if (t[i]) return t[i].exports;var o = t[i] = { i: i, l: !1, exports: {} };return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }return n.m = e, n.c = t, n.d = function (e, t, i) {\n      n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;var i = Object.create(null);if (n.r(i), Object.defineProperty(i, \"default\", { enumerable: !0, value: e }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(i, o, function (t) {\n        return e[t];\n      }.bind(null, o));return i;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 0);\n  }([function (e, t, n) {\n    (function (t) {\n      e.exports = t.Phoenix = n(2);\n    }).call(this, n(1));\n  }, function (e, t) {\n    var n;n = function () {\n      return this;\n    }();try {\n      n = n || Function(\"return this\")() || (0, eval)(\"this\");\n    } catch (e) {\n      \"object\" == typeof window && (n = window);\n    }e.exports = n;\n  }, function (e, t, n) {\n    \"use strict\";\n    function i(e) {\n      return function (e) {\n        if (Array.isArray(e)) {\n          for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];return n;\n        }\n      }(e) || function (e) {\n        if (Symbol.iterator in Object(e) || \"[object Arguments]\" === Object.prototype.toString.call(e)) return Array.from(e);\n      }(e) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n      }();\n    }function o(e) {\n      return (o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }function r(e, t) {\n      return function (e) {\n        if (Array.isArray(e)) return e;\n      }(e) || function (e, t) {\n        var n = [],\n            i = !0,\n            o = !1,\n            r = void 0;try {\n          for (var s, a = e[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); i = !0);\n        } catch (e) {\n          o = !0, r = e;\n        } finally {\n          try {\n            i || null == a.return || a.return();\n          } finally {\n            if (o) throw r;\n          }\n        }return n;\n      }(e, t) || function () {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }();\n    }function s(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }function a(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n      }\n    }function c(e, t, n) {\n      return t && a(e.prototype, t), n && a(e, n), e;\n    }n.r(t), n.d(t, \"Channel\", function () {\n      return b;\n    }), n.d(t, \"Socket\", function () {\n      return R;\n    }), n.d(t, \"LongPoll\", function () {\n      return w;\n    }), n.d(t, \"Ajax\", function () {\n      return C;\n    }), n.d(t, \"Presence\", function () {\n      return S;\n    });var u = \"undefined\" != typeof self ? self : null,\n        h = \"undefined\" != typeof window ? window : null,\n        l = u || h || void 0,\n        f = { connecting: 0, open: 1, closing: 2, closed: 3 },\n        p = 1e4,\n        d = { closed: \"closed\", errored: \"errored\", joined: \"joined\", joining: \"joining\", leaving: \"leaving\" },\n        v = { close: \"phx_close\", error: \"phx_error\", join: \"phx_join\", reply: \"phx_reply\", leave: \"phx_leave\" },\n        y = [v.close, v.error, v.join, v.reply, v.leave],\n        g = { longpoll: \"longpoll\", websocket: \"websocket\" },\n        m = function (e) {\n      if (\"function\" == typeof e) return e;return function () {\n        return e;\n      };\n    },\n        k = function () {\n      function e(t, n, i, o) {\n        s(this, e), this.channel = t, this.event = n, this.payload = i || function () {\n          return {};\n        }, this.receivedResp = null, this.timeout = o, this.timeoutTimer = null, this.recHooks = [], this.sent = !1;\n      }return c(e, [{ key: \"resend\", value: function (e) {\n          this.timeout = e, this.reset(), this.send();\n        } }, { key: \"send\", value: function () {\n          this.hasReceived(\"timeout\") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({ topic: this.channel.topic, event: this.event, payload: this.payload(), ref: this.ref, join_ref: this.channel.joinRef() }));\n        } }, { key: \"receive\", value: function (e, t) {\n          return this.hasReceived(e) && t(this.receivedResp.response), this.recHooks.push({ status: e, callback: t }), this;\n        } }, { key: \"reset\", value: function () {\n          this.cancelRefEvent(), this.ref = null, this.refEvent = null, this.receivedResp = null, this.sent = !1;\n        } }, { key: \"matchReceive\", value: function (e) {\n          var t = e.status,\n              n = e.response;e.ref;this.recHooks.filter(function (e) {\n            return e.status === t;\n          }).forEach(function (e) {\n            return e.callback(n);\n          });\n        } }, { key: \"cancelRefEvent\", value: function () {\n          this.refEvent && this.channel.off(this.refEvent);\n        } }, { key: \"cancelTimeout\", value: function () {\n          clearTimeout(this.timeoutTimer), this.timeoutTimer = null;\n        } }, { key: \"startTimeout\", value: function () {\n          var e = this;this.timeoutTimer && this.cancelTimeout(), this.ref = this.channel.socket.makeRef(), this.refEvent = this.channel.replyEventName(this.ref), this.channel.on(this.refEvent, function (t) {\n            e.cancelRefEvent(), e.cancelTimeout(), e.receivedResp = t, e.matchReceive(t);\n          }), this.timeoutTimer = setTimeout(function () {\n            e.trigger(\"timeout\", {});\n          }, this.timeout);\n        } }, { key: \"hasReceived\", value: function (e) {\n          return this.receivedResp && this.receivedResp.status === e;\n        } }, { key: \"trigger\", value: function (e, t) {\n          this.channel.trigger(this.refEvent, { status: e, response: t });\n        } }]), e;\n    }(),\n        b = function () {\n      function e(t, n, i) {\n        var o = this;s(this, e), this.state = d.closed, this.topic = t, this.params = m(n || {}), this.socket = i, this.bindings = [], this.bindingRef = 0, this.timeout = this.socket.timeout, this.joinedOnce = !1, this.joinPush = new k(this, v.join, this.params, this.timeout), this.pushBuffer = [], this.rejoinTimer = new T(function () {\n          return o.rejoinUntilConnected();\n        }, this.socket.reconnectAfterMs), this.joinPush.receive(\"ok\", function () {\n          o.state = d.joined, o.rejoinTimer.reset(), o.pushBuffer.forEach(function (e) {\n            return e.send();\n          }), o.pushBuffer = [];\n        }), this.onClose(function () {\n          o.rejoinTimer.reset(), o.socket.hasLogger() && o.socket.log(\"channel\", \"close \".concat(o.topic, \" \").concat(o.joinRef())), o.state = d.closed, o.socket.remove(o);\n        }), this.onError(function (e) {\n          o.isLeaving() || o.isClosed() || (o.socket.hasLogger() && o.socket.log(\"channel\", \"error \".concat(o.topic), e), o.state = d.errored, o.rejoinTimer.scheduleTimeout());\n        }), this.joinPush.receive(\"timeout\", function () {\n          o.isJoining() && (o.socket.hasLogger() && o.socket.log(\"channel\", \"timeout \".concat(o.topic, \" (\").concat(o.joinRef(), \")\"), o.joinPush.timeout), new k(o, v.leave, m({}), o.timeout).send(), o.state = d.errored, o.joinPush.reset(), o.rejoinTimer.scheduleTimeout());\n        }), this.on(v.reply, function (e, t) {\n          o.trigger(o.replyEventName(t), e);\n        });\n      }return c(e, [{ key: \"rejoinUntilConnected\", value: function () {\n          this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this.rejoin();\n        } }, { key: \"join\", value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;if (this.joinedOnce) throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");return this.joinedOnce = !0, this.rejoin(e), this.joinPush;\n        } }, { key: \"onClose\", value: function (e) {\n          this.on(v.close, e);\n        } }, { key: \"onError\", value: function (e) {\n          return this.on(v.error, function (t) {\n            return e(t);\n          });\n        } }, { key: \"on\", value: function (e, t) {\n          var n = this.bindingRef++;return this.bindings.push({ event: e, ref: n, callback: t }), n;\n        } }, { key: \"off\", value: function (e, t) {\n          this.bindings = this.bindings.filter(function (n) {\n            return !(n.event === e && (void 0 === t || t === n.ref));\n          });\n        } }, { key: \"canPush\", value: function () {\n          return this.socket.isConnected() && this.isJoined();\n        } }, { key: \"push\", value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.timeout;if (!this.joinedOnce) throw new Error(\"tried to push '\".concat(e, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\"));var i = new k(this, e, function () {\n            return t;\n          }, n);return this.canPush() ? i.send() : (i.startTimeout(), this.pushBuffer.push(i)), i;\n        } }, { key: \"leave\", value: function () {\n          var e = this,\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;this.state = d.leaving;var n = function () {\n            e.socket.hasLogger() && e.socket.log(\"channel\", \"leave \".concat(e.topic)), e.trigger(v.close, \"leave\");\n          },\n              i = new k(this, v.leave, m({}), t);return i.receive(\"ok\", function () {\n            return n();\n          }).receive(\"timeout\", function () {\n            return n();\n          }), i.send(), this.canPush() || i.trigger(\"ok\", {}), i;\n        } }, { key: \"onMessage\", value: function (e, t, n) {\n          return t;\n        } }, { key: \"isLifecycleEvent\", value: function (e) {\n          return y.indexOf(e) >= 0;\n        } }, { key: \"isMember\", value: function (e, t, n, i) {\n          return this.topic === e && (!i || i === this.joinRef() || !this.isLifecycleEvent(t) || (this.socket.hasLogger() && this.socket.log(\"channel\", \"dropping outdated message\", { topic: e, event: t, payload: n, joinRef: i }), !1));\n        } }, { key: \"joinRef\", value: function () {\n          return this.joinPush.ref;\n        } }, { key: \"sendJoin\", value: function (e) {\n          this.state = d.joining, this.joinPush.resend(e);\n        } }, { key: \"rejoin\", value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;this.isLeaving() || this.sendJoin(e);\n        } }, { key: \"trigger\", value: function (e, t, n, i) {\n          var o = this.onMessage(e, t, n, i);if (t && !o) throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");for (var r = 0; r < this.bindings.length; r++) {\n            var s = this.bindings[r];s.event === e && s.callback(o, n, i || this.joinRef());\n          }\n        } }, { key: \"replyEventName\", value: function (e) {\n          return \"chan_reply_\".concat(e);\n        } }, { key: \"isClosed\", value: function () {\n          return this.state === d.closed;\n        } }, { key: \"isErrored\", value: function () {\n          return this.state === d.errored;\n        } }, { key: \"isJoined\", value: function () {\n          return this.state === d.joined;\n        } }, { key: \"isJoining\", value: function () {\n          return this.state === d.joining;\n        } }, { key: \"isLeaving\", value: function () {\n          return this.state === d.leaving;\n        } }]), e;\n    }(),\n        j = { encode: function (e, t) {\n        var n = [e.join_ref, e.ref, e.topic, e.event, e.payload];return t(JSON.stringify(n));\n      }, decode: function (e, t) {\n        var n = r(JSON.parse(e), 5);return t({ join_ref: n[0], ref: n[1], topic: n[2], event: n[3], payload: n[4] });\n      } },\n        R = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};s(this, e), this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] }, this.channels = [], this.sendBuffer = [], this.ref = 0, this.timeout = i.timeout || p, this.transport = i.transport || l.WebSocket || w, this.defaultEncoder = j.encode, this.defaultDecoder = j.decode, this.transport !== w ? (this.encode = i.encode || this.defaultEncoder, this.decode = i.decode || this.defaultDecoder) : (this.encode = this.defaultEncoder, this.decode = this.defaultDecoder), this.heartbeatIntervalMs = i.heartbeatIntervalMs || 3e4, this.reconnectAfterMs = i.reconnectAfterMs || function (e) {\n          return [1e3, 2e3, 5e3, 1e4][e - 1] || 1e4;\n        }, this.logger = i.logger || null, this.longpollerTimeout = i.longpollerTimeout || 2e4, this.params = m(i.params || {}), this.endPoint = \"\".concat(t, \"/\").concat(g.websocket), this.heartbeatTimer = null, this.pendingHeartbeatRef = null, this.reconnectTimer = new T(function () {\n          n.teardown(function () {\n            return n.connect();\n          });\n        }, this.reconnectAfterMs);\n      }return c(e, [{ key: \"protocol\", value: function () {\n          return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n        } }, { key: \"endPointURL\", value: function () {\n          var e = C.appendParams(C.appendParams(this.endPoint, this.params()), { vsn: \"2.0.0\" });return \"/\" !== e.charAt(0) ? e : \"/\" === e.charAt(1) ? \"\".concat(this.protocol(), \":\").concat(e) : \"\".concat(this.protocol(), \"://\").concat(location.host).concat(e);\n        } }, { key: \"disconnect\", value: function (e, t, n) {\n          this.reconnectTimer.reset(), this.teardown(e, t, n);\n        } }, { key: \"connect\", value: function (e) {\n          var t = this;e && (console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\"), this.params = m(e)), this.conn || (this.conn = new this.transport(this.endPointURL()), this.conn.timeout = this.longpollerTimeout, this.conn.onopen = function () {\n            return t.onConnOpen();\n          }, this.conn.onerror = function (e) {\n            return t.onConnError(e);\n          }, this.conn.onmessage = function (e) {\n            return t.onConnMessage(e);\n          }, this.conn.onclose = function (e) {\n            return t.onConnClose(e);\n          });\n        } }, { key: \"log\", value: function (e, t, n) {\n          this.logger(e, t, n);\n        } }, { key: \"hasLogger\", value: function () {\n          return null !== this.logger;\n        } }, { key: \"onOpen\", value: function (e) {\n          this.stateChangeCallbacks.open.push(e);\n        } }, { key: \"onClose\", value: function (e) {\n          this.stateChangeCallbacks.close.push(e);\n        } }, { key: \"onError\", value: function (e) {\n          this.stateChangeCallbacks.error.push(e);\n        } }, { key: \"onMessage\", value: function (e) {\n          this.stateChangeCallbacks.message.push(e);\n        } }, { key: \"onConnOpen\", value: function () {\n          this.hasLogger() && this.log(\"transport\", \"connected to \".concat(this.endPointURL())), this.flushSendBuffer(), this.reconnectTimer.reset(), this.resetHeartbeat(), this.stateChangeCallbacks.open.forEach(function (e) {\n            return e();\n          });\n        } }, { key: \"resetHeartbeat\", value: function () {\n          var e = this;this.conn.skipHeartbeat || (this.pendingHeartbeatRef = null, clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(function () {\n            return e.sendHeartbeat();\n          }, this.heartbeatIntervalMs));\n        } }, { key: \"teardown\", value: function (e, t, n) {\n          this.conn && (this.conn.onclose = function () {}, t ? this.conn.close(t, n || \"\") : this.conn.close(), this.conn = null), e && e();\n        } }, { key: \"onConnClose\", value: function (e) {\n          this.hasLogger() && this.log(\"transport\", \"close\", e), this.triggerChanError(), clearInterval(this.heartbeatTimer), e && 1e3 !== e.code && this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(function (t) {\n            return t(e);\n          });\n        } }, { key: \"onConnError\", value: function (e) {\n          this.hasLogger() && this.log(\"transport\", e), this.triggerChanError(), this.stateChangeCallbacks.error.forEach(function (t) {\n            return t(e);\n          });\n        } }, { key: \"triggerChanError\", value: function () {\n          this.channels.forEach(function (e) {\n            return e.trigger(v.error);\n          });\n        } }, { key: \"connectionState\", value: function () {\n          switch (this.conn && this.conn.readyState) {case f.connecting:\n              return \"connecting\";case f.open:\n              return \"open\";case f.closing:\n              return \"closing\";default:\n              return \"closed\";}\n        } }, { key: \"isConnected\", value: function () {\n          return \"open\" === this.connectionState();\n        } }, { key: \"remove\", value: function (e) {\n          this.channels = this.channels.filter(function (t) {\n            return t.joinRef() !== e.joinRef();\n          });\n        } }, { key: \"channel\", value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = new b(e, t, this);return this.channels.push(n), n;\n        } }, { key: \"push\", value: function (e) {\n          var t = this;if (this.hasLogger()) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                r = e.ref,\n                s = e.join_ref;this.log(\"push\", \"\".concat(n, \" \").concat(i, \" (\").concat(s, \", \").concat(r, \")\"), o);\n          }this.isConnected() ? this.encode(e, function (e) {\n            return t.conn.send(e);\n          }) : this.sendBuffer.push(function () {\n            return t.encode(e, function (e) {\n              return t.conn.send(e);\n            });\n          });\n        } }, { key: \"makeRef\", value: function () {\n          var e = this.ref + 1;return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString();\n        } }, { key: \"sendHeartbeat\", value: function () {\n          if (this.isConnected()) {\n            if (this.pendingHeartbeatRef) return this.pendingHeartbeatRef = null, this.hasLogger() && this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\"), void this.conn.close(1e3, \"hearbeat timeout\");this.pendingHeartbeatRef = this.makeRef(), this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n          }\n        } }, { key: \"flushSendBuffer\", value: function () {\n          this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(function (e) {\n            return e();\n          }), this.sendBuffer = []);\n        } }, { key: \"onConnMessage\", value: function (e) {\n          var t = this;this.decode(e.data, function (e) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                r = e.ref,\n                s = e.join_ref;r && r === t.pendingHeartbeatRef && (t.pendingHeartbeatRef = null), t.hasLogger() && t.log(\"receive\", \"\".concat(o.status || \"\", \" \").concat(n, \" \").concat(i, \" \").concat(r && \"(\" + r + \")\" || \"\"), o);for (var a = 0; a < t.channels.length; a++) {\n              var c = t.channels[a];c.isMember(n, i, o, s) && c.trigger(i, o, r, s);\n            }for (var u = 0; u < t.stateChangeCallbacks.message.length; u++) t.stateChangeCallbacks.message[u](e);\n          });\n        } }]), e;\n    }(),\n        w = function () {\n      function e(t) {\n        s(this, e), this.endPoint = null, this.token = null, this.skipHeartbeat = !0, this.onopen = function () {}, this.onerror = function () {}, this.onmessage = function () {}, this.onclose = function () {}, this.pollEndpoint = this.normalizeEndpoint(t), this.readyState = f.connecting, this.poll();\n      }return c(e, [{ key: \"normalizeEndpoint\", value: function (e) {\n          return e.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + g.websocket), \"$1/\" + g.longpoll);\n        } }, { key: \"endpointURL\", value: function () {\n          return C.appendParams(this.pollEndpoint, { token: this.token });\n        } }, { key: \"closeAndRetry\", value: function () {\n          this.close(), this.readyState = f.connecting;\n        } }, { key: \"ontimeout\", value: function () {\n          this.onerror(\"timeout\"), this.closeAndRetry();\n        } }, { key: \"poll\", value: function () {\n          var e = this;this.readyState !== f.open && this.readyState !== f.connecting || C.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (t) {\n            if (t) {\n              var n = t.status,\n                  i = t.token,\n                  o = t.messages;e.token = i;\n            } else n = 0;switch (n) {case 200:\n                o.forEach(function (t) {\n                  return e.onmessage({ data: t });\n                }), e.poll();break;case 204:\n                e.poll();break;case 410:\n                e.readyState = f.open, e.onopen(), e.poll();break;case 0:case 500:\n                e.onerror(), e.closeAndRetry();break;default:\n                throw new Error(\"unhandled poll status \".concat(n));}\n          });\n        } }, { key: \"send\", value: function (e) {\n          var t = this;C.request(\"POST\", this.endpointURL(), \"application/json\", e, this.timeout, this.onerror.bind(this, \"timeout\"), function (e) {\n            e && 200 === e.status || (t.onerror(e && e.status), t.closeAndRetry());\n          });\n        } }, { key: \"close\", value: function (e, t) {\n          this.readyState = f.closed, this.onclose();\n        } }]), e;\n    }(),\n        C = function () {\n      function e() {\n        s(this, e);\n      }return c(e, null, [{ key: \"request\", value: function (e, t, n, i, o, r, s) {\n          if (l.XDomainRequest) {\n            var a = new XDomainRequest();this.xdomainRequest(a, e, t, i, o, r, s);\n          } else {\n            var c = l.XMLHttpRequest ? new l.XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\");this.xhrRequest(c, e, t, n, i, o, r, s);\n          }\n        } }, { key: \"xdomainRequest\", value: function (e, t, n, i, o, r, s) {\n          var a = this;e.timeout = o, e.open(t, n), e.onload = function () {\n            var t = a.parseJSON(e.responseText);s && s(t);\n          }, r && (e.ontimeout = r), e.onprogress = function () {}, e.send(i);\n        } }, { key: \"xhrRequest\", value: function (e, t, n, i, o, r, s, a) {\n          var c = this;e.open(t, n, !0), e.timeout = r, e.setRequestHeader(\"Content-Type\", i), e.onerror = function () {\n            a && a(null);\n          }, e.onreadystatechange = function () {\n            if (e.readyState === c.states.complete && a) {\n              var t = c.parseJSON(e.responseText);a(t);\n            }\n          }, s && (e.ontimeout = s), e.send(o);\n        } }, { key: \"parseJSON\", value: function (e) {\n          if (!e || \"\" === e) return null;try {\n            return JSON.parse(e);\n          } catch (t) {\n            return console && console.log(\"failed to parse JSON response\", e), null;\n          }\n        } }, { key: \"serialize\", value: function (e, t) {\n          var n = [];for (var i in e) if (e.hasOwnProperty(i)) {\n            var r = t ? \"\".concat(t, \"[\").concat(i, \"]\") : i,\n                s = e[i];\"object\" === o(s) ? n.push(this.serialize(s, r)) : n.push(encodeURIComponent(r) + \"=\" + encodeURIComponent(s));\n          }return n.join(\"&\");\n        } }, { key: \"appendParams\", value: function (e, t) {\n          if (0 === Object.keys(t).length) return e;var n = e.match(/\\?/) ? \"&\" : \"?\";return \"\".concat(e).concat(n).concat(this.serialize(t));\n        } }]), e;\n    }();C.states = { complete: 4 };var S = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};s(this, e);var o = i.events || { state: \"presence_state\", diff: \"presence_diff\" };this.state = {}, this.pendingDiffs = [], this.channel = t, this.joinRef = null, this.caller = { onJoin: function () {}, onLeave: function () {}, onSync: function () {} }, this.channel.on(o.state, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;n.joinRef = n.channel.joinRef(), n.state = e.syncState(n.state, t, o, r), n.pendingDiffs.forEach(function (t) {\n            n.state = e.syncDiff(n.state, t, o, r);\n          }), n.pendingDiffs = [], s();\n        }), this.channel.on(o.diff, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;n.inPendingSyncState() ? n.pendingDiffs.push(t) : (n.state = e.syncDiff(n.state, t, o, r), s());\n        });\n      }return c(e, [{ key: \"onJoin\", value: function (e) {\n          this.caller.onJoin = e;\n        } }, { key: \"onLeave\", value: function (e) {\n          this.caller.onLeave = e;\n        } }, { key: \"onSync\", value: function (e) {\n          this.caller.onSync = e;\n        } }, { key: \"list\", value: function (t) {\n          return e.list(this.state, t);\n        } }, { key: \"inPendingSyncState\", value: function () {\n          return !this.joinRef || this.joinRef !== this.channel.joinRef();\n        } }], [{ key: \"syncState\", value: function (e, t, n, i) {\n          var o = this,\n              r = this.clone(e),\n              s = {},\n              a = {};return this.map(r, function (e, n) {\n            t[e] || (a[e] = n);\n          }), this.map(t, function (e, t) {\n            var n = r[e];if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = n.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  u = t.metas.filter(function (e) {\n                return c.indexOf(e.phx_ref) < 0;\n              }),\n                  h = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              });u.length > 0 && (s[e] = t, s[e].metas = u), h.length > 0 && (a[e] = o.clone(n), a[e].metas = h);\n            } else s[e] = t;\n          }), this.syncDiff(r, { joins: s, leaves: a }, n, i);\n        } }, { key: \"syncDiff\", value: function (e, t, n, o) {\n          var r = t.joins,\n              s = t.leaves,\n              a = this.clone(e);return n || (n = function () {}), o || (o = function () {}), this.map(r, function (e, t) {\n            var o = a[e];if (a[e] = t, o) {\n              var r,\n                  s = a[e].metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = o.metas.filter(function (e) {\n                return s.indexOf(e.phx_ref) < 0;\n              });(r = a[e].metas).unshift.apply(r, i(c));\n            }n(e, o, t);\n          }), this.map(s, function (e, t) {\n            var n = a[e];if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              });n.metas = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              }), o(e, n, t), 0 === n.metas.length && delete a[e];\n            }\n          }), a;\n        } }, { key: \"list\", value: function (e, t) {\n          return t || (t = function (e, t) {\n            return t;\n          }), this.map(e, function (e, n) {\n            return t(e, n);\n          });\n        } }, { key: \"map\", value: function (e, t) {\n          return Object.getOwnPropertyNames(e).map(function (n) {\n            return t(n, e[n]);\n          });\n        } }, { key: \"clone\", value: function (e) {\n          return JSON.parse(JSON.stringify(e));\n        } }]), e;\n    }(),\n        T = function () {\n      function e(t, n) {\n        s(this, e), this.callback = t, this.timerCalc = n, this.timer = null, this.tries = 0;\n      }return c(e, [{ key: \"reset\", value: function () {\n          this.tries = 0, clearTimeout(this.timer);\n        } }, { key: \"scheduleTimeout\", value: function () {\n          var e = this;clearTimeout(this.timer), this.timer = setTimeout(function () {\n            e.tries = e.tries + 1, e.callback();\n          }, this.timerCalc(this.tries + 1));\n        } }]), e;\n    }();\n  }]);\n});\n\n//# sourceURL=webpack://phoenix_live_view/../deps/phoenix/priv/static/phoenix.js?");

/***/ }),

/***/ "./js/phoenix_live_view.js-exposed":
/*!*****************************************!*\
  !*** ./js/phoenix_live_view.js-exposed ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {if(!global[\"Phoenix\"]) global[\"Phoenix\"] = {};\nmodule.exports = global[\"Phoenix\"][\"LiveView\"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./phoenix_live_view.js */ \"./node_modules/babel-loader/lib/index.js!./js/phoenix_live_view.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../home/vagrant/.nvm/versions/node/v8.9.1/lib/node_modules/webpack/buildin/global.js */ \"../../../home/vagrant/.nvm/versions/node/v8.9.1/lib/node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://phoenix_live_view/./js/phoenix_live_view.js-exposed?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./js/phoenix_live_view.js":
/*!*****************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./js/phoenix_live_view.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LiveSocket = exports.debug = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /*\n                                                                                                                                                                                                                                                                              ================================================================================\n                                                                                                                                                                                                                                                                              Phoenix LiveView Javascript Client \n                                                                                                                                                                                                                                                                              ================================================================================\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              ## Usage\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              Instantiate a single LiveSocket instances to enable LiveView\n                                                                                                                                                                                                                                                                              client/server interaction, for example:\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                  import LiveSocket from \"live_view\"\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                  let liveSocket = new LiveSocket(\"/live\")\n                                                                                                                                                                                                                                                                                  liveSocket.connect()\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              A LiveSocket can also be created from an existing socket:\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                  import { Socket } from \"phoenix\"\n                                                                                                                                                                                                                                                                                  import LiveSocket from \"live_view\"\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                  let socket = new Socket(\"/live\")\n                                                                                                                                                                                                                                                                                  let liveSocket = new LiveSocket(socket)\n                                                                                                                                                                                                                                                                                  liveSocket.connect()\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              All options are passed directly to the `Phoenix.Socket` constructor,\n                                                                                                                                                                                                                                                                              except for the following LiveView specific options:\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                * `bindingPrefix` - the prefix to use for phoenix bindings. Defaults `\"phx-\"`\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              ## Events\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              ### Click Events\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              When pushed, the value sent to the server will be chosen with the\n                                                                                                                                                                                                                                                                              following priority:\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                - An optional `\"phx-value\"` binding on the clicked element\n                                                                                                                                                                                                                                                                                - The clicked element's `value` property\n                                                                                                                                                                                                                                                                                - An empty string\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              ### Key Events\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              The onkeypress, onkeydown, and onkeyup events are supported via\n                                                                                                                                                                                                                                                                              the `phx-keypress`, `phx-keydown`, and `phx-keyup` bindings. By\n                                                                                                                                                                                                                                                                              default, the bound element will be the event listener, but an\n                                                                                                                                                                                                                                                                              optional `phx-target` may be provided which may be `\"document\"`,\n                                                                                                                                                                                                                                                                              `\"window\"`, or the DOM id of a target element.\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              When pushed, the value sent to the server will be the event's keyCode.\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              ## Forms and input handling\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              The JavaScript client is always the source of truth for current\n                                                                                                                                                                                                                                                                              input values. For any given input with focus, LiveView will never\n                                                                                                                                                                                                                                                                              overwrite the input's current value, even if it deviates from\n                                                                                                                                                                                                                                                                              the server's rendered updates. This works well for updates where\n                                                                                                                                                                                                                                                                              major side effects are not expected, such as form validation errors,\n                                                                                                                                                                                                                                                                              or additive UX around the user's input values as they fill out a form.\n                                                                                                                                                                                                                                                                              For these usecases, the `phx-change` input does not concern itself\n                                                                                                                                                                                                                                                                              with disabling input editing while an event to the server is inflight.\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              The `phx-submit` event is used for form submissions where major side-effects\n                                                                                                                                                                                                                                                                              typically happen, such as rendering new containers, calling an external\n                                                                                                                                                                                                                                                                              service, or redirecting to a new page. For these use-cases, the form inputs\n                                                                                                                                                                                                                                                                              are set to `readonly` on submit, and any submit button is disabled until\n                                                                                                                                                                                                                                                                              the client gets an acknowledgement that the server has processed the\n                                                                                                                                                                                                                                                                              `phx-submit` event. Following an acknowledgement, any updates are patched\n                                                                                                                                                                                                                                                                              to the DOM as normal, and the last input with focus is restored if the\n                                                                                                                                                                                                                                                                              user has not otherwised focused on a new input during submission.\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              To handle latent form submissions, any HTML tag can be annotated with\n                                                                                                                                                                                                                                                                              `phx-disable-with`, which swaps the element's `innerText` with the provided\n                                                                                                                                                                                                                                                                              value during form submission. For example, the following code would change\n                                                                                                                                                                                                                                                                              the \"Save\" button to \"Saving...\", and restore it to \"Save\" on acknowledgement:\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                  <button type=\"submit\" phx-disable-with=\"Saving...\">Save</button>\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              ## Loading state and Errors\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              By default, the following classes are applied to the Live View's parent\n                                                                                                                                                                                                                                                                              container:\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                - `\"phx-connected\"` - applied when the view has connected to the server\n                                                                                                                                                                                                                                                                                - `\"phx-disconnected\"` - applied when the view is not connected to the server\n                                                                                                                                                                                                                                                                                - `\"phx-error\"` - applied when an error occurs on the server. Note, this\n                                                                                                                                                                                                                                                                                  class will be applied in conjunction with `\"phx-disconnected\"` connection\n                                                                                                                                                                                                                                                                                  to the server is lost.\n                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                              In addition to applied classes, an empty `\"phx-loader\"` exists adjacent\n                                                                                                                                                                                                                                                                              to every LiveView, and its display status is toggled automatically based on\n                                                                                                                                                                                                                                                                              connection and error class changes. This behavior may be disabled by overriding\n                                                                                                                                                                                                                                                                              `.phx-loader` in your css to `display: none!important`.\n                                                                                                                                                                                                                                                                              */\n\nvar _phoenix = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.js\");\n\nvar _morphdom = __webpack_require__(/*! morphdom */ \"./node_modules/morphdom/dist/morphdom.js\");\n\nvar _morphdom2 = _interopRequireDefault(_morphdom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PHX_VIEW = \"data-phx-view\";\nvar PHX_CONNECTED_CLASS = \"phx-connected\";\nvar PHX_DISCONNECTED_CLASS = \"phx-disconnected\";\nvar PHX_ERROR_CLASS = \"phx-error\";\nvar PHX_PARENT_ID = \"data-phx-parent-id\";\nvar PHX_VIEW_SELECTOR = \"[\" + PHX_VIEW + \"]\";\nvar PHX_ERROR_FOR = \"data-phx-error-for\";\nvar PHX_HAS_FOCUSED = \"data-phx-has-focused\";\nvar PHX_BOUND = \"data-phx-bound\";\nvar FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\"];\nvar PHX_HAS_SUBMITTED = \"data-phx-has-submitted\";\nvar PHX_SESSION = \"data-phx-session\";\nvar PHX_READONLY = \"data-phx-readonly\";\nvar PHX_DISABLED = \"data-phx-disabled\";\nvar PHX_DISABLE_WITH = \"disable-with\";\nvar LOADER_TIMEOUT = 100;\nvar LOADER_ZOOM = 2;\nvar BINDING_PREFIX = \"phx-\";\nvar PUSH_TIMEOUT = 20000;\n\nvar debug = exports.debug = function debug(view, kind, msg, obj) {\n  console.log(view.id + \" \" + kind + \": \" + msg + \" - \", obj);\n};\n\nvar isObject = function isObject(obj) {\n  return (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" && !(obj instanceof Array);\n};\n\nvar isEmpty = function isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nvar maybe = function maybe(el, key) {\n  if (el) {\n    return el[key];\n  } else {\n    return null;\n  }\n};\n\nvar recursiveMerge = function recursiveMerge(target, source) {\n  for (var key in source) {\n    var val = source[key];\n    if (isObject(val) && target[key]) {\n      recursiveMerge(target[key], val);\n    } else {\n      target[key] = val;\n    }\n  }\n};\n\nvar Rendered = {\n  mergeDiff: function mergeDiff(source, diff) {\n    if (this.isNewFingerprint(diff)) {\n      return diff;\n    } else {\n      recursiveMerge(source, diff);\n      return source;\n    }\n  },\n  isNewFingerprint: function isNewFingerprint(diff) {\n    return diff.static;\n  },\n  toString: function toString(rendered) {\n    var output = { buffer: \"\" };\n    this.toOutputBuffer(rendered, output);\n    return output.buffer;\n  },\n  toOutputBuffer: function toOutputBuffer(rendered, output) {\n    if (rendered.dynamics) {\n      return this.comprehensionToBuffer(rendered, output);\n    }\n    var statics = rendered.static;\n\n\n    output.buffer += statics[0];\n    for (var i = 1; i < statics.length; i++) {\n      this.dynamicToBuffer(rendered[i - 1], output);\n      output.buffer += statics[i];\n    }\n  },\n  comprehensionToBuffer: function comprehensionToBuffer(rendered, output) {\n    var dynamics = rendered.dynamics,\n        statics = rendered.static;\n\n\n    for (var d = 0; d < dynamics.length; d++) {\n      var dynamic = dynamics[d];\n      output.buffer += statics[0];\n      for (var i = 1; i < statics.length; i++) {\n        this.dynamicToBuffer(dynamic[i - 1], output);\n        output.buffer += statics[i];\n      }\n    }\n  },\n  dynamicToBuffer: function dynamicToBuffer(rendered, output) {\n    if (isObject(rendered)) {\n      this.toOutputBuffer(rendered, output);\n    } else {\n      output.buffer += rendered;\n    }\n  }\n};\n\n// todo document LiveSocket specific options like viewLogger\n\nvar LiveSocket = exports.LiveSocket = function () {\n  function LiveSocket(urlOrSocket) {\n    var _this = this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, LiveSocket);\n\n    this.unloaded = false;\n    window.addEventListener(\"beforeunload\", function (e) {\n      _this.unloaded = true;\n    });\n    this.socket = this.buildSocket(urlOrSocket, opts);\n    this.socket.onOpen(function () {\n      return _this.unloaded = false;\n    });\n    this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n    this.opts = opts;\n    this.views = {};\n    this.viewLogger = opts.viewLogger;\n    this.activeElement = null;\n    this.prevActive = null;\n  }\n\n  _createClass(LiveSocket, [{\n    key: \"buildSocket\",\n    value: function buildSocket(urlOrSocket, opts) {\n      var _this2 = this;\n\n      if (typeof urlOrSocket !== \"string\") {\n        return urlOrSocket;\n      }\n\n      if (!opts.reconnectAfterMs) {\n        opts.reconnectAfterMs = function (tries) {\n          if (_this2.unloaded) {\n            return [50, 100, 250][tries - 1] || 500;\n          } else {\n            return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n          }\n        };\n      }\n      return new _phoenix.Socket(urlOrSocket, opts);\n    }\n  }, {\n    key: \"log\",\n    value: function log(view, kind, msgCallback) {\n      if (this.viewLogger) {\n        var _msgCallback = msgCallback(),\n            _msgCallback2 = _slicedToArray(_msgCallback, 2),\n            msg = _msgCallback2[0],\n            obj = _msgCallback2[1];\n\n        this.viewLogger(view, kind, msg, obj);\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this3 = this;\n\n      if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n        this.joinRootViews();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", function () {\n          _this3.joinRootViews();\n        });\n      }\n      return this.socket.connect();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return this.socket.disconnect();\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic, params) {\n      return this.socket.channel(topic, params || {});\n    }\n  }, {\n    key: \"joinRootViews\",\n    value: function joinRootViews() {\n      var _this4 = this;\n\n      document.querySelectorAll(PHX_VIEW_SELECTOR + \":not([\" + PHX_PARENT_ID + \"])\").forEach(function (rootEl) {\n        _this4.joinView(rootEl);\n      });\n    }\n  }, {\n    key: \"joinView\",\n    value: function joinView(el, parentView) {\n      var view = new View(el, this, parentView);\n      this.views[view.id] = view;\n      view.join();\n    }\n  }, {\n    key: \"getViewById\",\n    value: function getViewById(id) {\n      return this.views[id];\n    }\n  }, {\n    key: \"onViewError\",\n    value: function onViewError(view) {\n      this.dropActiveElement(view);\n    }\n  }, {\n    key: \"destroyViewById\",\n    value: function destroyViewById(id) {\n      var view = this.views[id];\n      if (view) {\n        delete this.views[view.id];\n        view.destroy();\n      }\n    }\n  }, {\n    key: \"getBindingPrefix\",\n    value: function getBindingPrefix() {\n      return this.bindingPrefix;\n    }\n  }, {\n    key: \"setActiveElement\",\n    value: function setActiveElement(target) {\n      var _this5 = this;\n\n      if (this.activeElement === target) {\n        return;\n      }\n      this.activeElement = target;\n      var cancel = function cancel() {\n        if (target === _this5.activeElement) {\n          _this5.activeElement = null;\n        }\n        target.removeEventListener(\"mouseup\", _this5);\n        target.removeEventListener(\"touchend\", _this5);\n      };\n      target.addEventListener(\"mouseup\", cancel);\n      target.addEventListener(\"touchend\", cancel);\n    }\n  }, {\n    key: \"getActiveElement\",\n    value: function getActiveElement() {\n      if (document.activeElement === document.body) {\n        return this.activeElement || document.activeElement;\n      } else {\n        return document.activeElement;\n      }\n    }\n  }, {\n    key: \"dropActiveElement\",\n    value: function dropActiveElement(view) {\n      if (this.prevActive && view.ownsElement(this.prevActive)) {\n        this.prevActive = null;\n      }\n    }\n  }, {\n    key: \"restorePreviouslyActiveFocus\",\n    value: function restorePreviouslyActiveFocus() {\n      if (this.prevActive && this.prevActive !== document.body) {\n        this.prevActive.focus();\n      }\n    }\n  }, {\n    key: \"blurActiveElement\",\n    value: function blurActiveElement() {\n      this.prevActive = this.getActiveElement();\n      if (this.prevActive !== document.body) {\n        this.prevActive.blur();\n      }\n    }\n  }]);\n\n  return LiveSocket;\n}();\n\nvar Browser = {\n  setCookie: function setCookie(name, value) {\n    document.cookie = name + \"=\" + value;\n  },\n  getCookie: function getCookie(name) {\n    return document.cookie.replace(new RegExp(\"(?:(?:^|.*;s*)\" + name + \"s*=s*([^;]*).*$)|^.*$\"), \"$1\");\n  },\n  redirect: function redirect(toURL, flash) {\n    if (flash) {\n      Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\n    }\n    window.location = toURL;\n  }\n};\n\nvar DOM = {\n  disableForm: function disableForm(form, prefix) {\n    var disableWith = \"\" + prefix + PHX_DISABLE_WITH;\n    form.querySelectorAll(\"[\" + disableWith + \"]\").forEach(function (el) {\n      var value = el.getAttribute(disableWith);\n      el.setAttribute(disableWith + \"-restore\", el.innerText);\n      el.innerText = value;\n    });\n    form.querySelectorAll(\"button\").forEach(function (button) {\n      button.setAttribute(PHX_DISABLED, button.disabled);\n      button.disabled = true;\n    });\n    form.querySelectorAll(\"input\").forEach(function (input) {\n      input.setAttribute(PHX_READONLY, input.readOnly);\n      input.readOnly = true;\n    });\n  },\n  restoreDisabledForm: function restoreDisabledForm(form, prefix) {\n    var disableWith = \"\" + prefix + PHX_DISABLE_WITH;\n    form.querySelectorAll(\"[\" + disableWith + \"]\").forEach(function (el) {\n      var value = el.getAttribute(disableWith + \"-restore\");\n      if (value) {\n        el.innerText = value;\n        el.removeAttribute(disableWith + \"-restore\");\n      }\n    });\n    form.querySelectorAll(\"button\").forEach(function (button) {\n      var prev = button.getAttribute(PHX_DISABLED);\n      if (prev) {\n        button.disabled = prev === \"true\";\n        button.removeAttribute(PHX_DISABLED);\n      }\n    });\n    form.querySelectorAll(\"input\").forEach(function (input) {\n      var prev = input.getAttribute(PHX_READONLY);\n      if (prev) {\n        input.readOnly = prev === \"true\";\n        input.removeAttribute(PHX_READONLY);\n      }\n    });\n  },\n  discardError: function discardError(el) {\n    var field = el.getAttribute && el.getAttribute(PHX_ERROR_FOR);\n    if (!field) {\n      return;\n    }\n    var input = document.getElementById(field);\n\n    if (field && !(input.getAttribute(PHX_HAS_FOCUSED) || input.form.getAttribute(PHX_HAS_SUBMITTED))) {\n      el.style.display = \"none\";\n    }\n  },\n  isPhxChild: function isPhxChild(node) {\n    return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n  },\n  patch: function patch(view, container, id, html) {\n    var focused = view.liveSocket.getActiveElement();\n    var selectionStart = null;\n    var selectionEnd = null;\n    if (DOM.isTextualInput(focused)) {\n      selectionStart = focused.selectionStart;\n      selectionEnd = focused.selectionEnd;\n    }\n\n    (0, _morphdom2.default)(container, \"<div>\" + html + \"</div>\", {\n      childrenOnly: true,\n      onBeforeNodeAdded: function onBeforeNodeAdded(el) {\n        //input handling\n        DOM.discardError(el);\n        return el;\n      },\n      onNodeAdded: function onNodeAdded(el) {\n        // nested view handling\n        if (DOM.isPhxChild(el) && view.ownsElement(el)) {\n          view.onNewChildAdded(el);\n          return true;\n        }\n        view.maybeBindAddedNode(el);\n      },\n      onBeforeNodeDiscarded: function onBeforeNodeDiscarded(el) {\n        // nested view handling\n        if (DOM.isPhxChild(el)) {\n          view.liveSocket.destroyViewById(el.id);\n          return true;\n        }\n      },\n      onBeforeElUpdated: function onBeforeElUpdated(fromEl, toEl) {\n        // nested view handling\n        if (DOM.isPhxChild(toEl)) {\n          DOM.mergeAttrs(fromEl, toEl);\n          return false;\n        }\n\n        // input handling\n        if (fromEl.getAttribute && fromEl.getAttribute(PHX_HAS_SUBMITTED)) {\n          toEl.setAttribute(PHX_HAS_SUBMITTED, true);\n        }\n        if (fromEl.getAttribute && fromEl.getAttribute(PHX_HAS_FOCUSED)) {\n          toEl.setAttribute(PHX_HAS_FOCUSED, true);\n        }\n        DOM.discardError(toEl);\n\n        if (DOM.isTextualInput(fromEl) && fromEl === focused) {\n          DOM.mergeInputs(fromEl, toEl);\n          return false;\n        } else {\n          return true;\n        }\n      }\n    });\n\n    DOM.restoreFocus(focused, selectionStart, selectionEnd);\n    document.dispatchEvent(new Event(\"phx:update\"));\n  },\n  mergeAttrs: function mergeAttrs(target, source) {\n    source.getAttributeNames().forEach(function (name) {\n      var value = source.getAttribute(name);\n      target.setAttribute(name, value);\n    });\n  },\n  mergeInputs: function mergeInputs(target, source) {\n    DOM.mergeAttrs(target, source);\n    target.readOnly = source.readOnly;\n  },\n  restoreFocus: function restoreFocus(focused, selectionStart, selectionEnd) {\n    if (!DOM.isTextualInput(focused)) {\n      return;\n    }\n    if (focused.value === \"\" || focused.readOnly) {\n      focused.blur();\n    }\n    focused.focus();\n    if (focused.setSelectionRange && focused.type === \"text\" || focused.type === \"textarea\") {\n      focused.setSelectionRange(selectionStart, selectionEnd);\n    }\n  },\n  isTextualInput: function isTextualInput(el) {\n    return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n  }\n};\n\nvar View = function () {\n  function View(el, liveSocket, parentView) {\n    var _this6 = this;\n\n    _classCallCheck(this, View);\n\n    this.liveSocket = liveSocket;\n    this.parent = parentView;\n    this.newChildrenAdded = false;\n    this.gracefullyClosed = false;\n    this.el = el;\n    this.bindingPrefix = liveSocket.getBindingPrefix();\n    this.loader = this.el.nextElementSibling;\n    this.id = this.el.id;\n    this.view = this.el.getAttribute(PHX_VIEW);\n    this.hasBoundUI = false;\n    this.channel = this.liveSocket.channel(\"lv:\" + this.id, function () {\n      return { session: _this6.getSession() };\n    });\n    this.loaderTimer = setTimeout(function () {\n      return _this6.showLoader();\n    }, LOADER_TIMEOUT);\n    this.bindChannel();\n  }\n\n  _createClass(View, [{\n    key: \"getSession\",\n    value: function getSession() {\n      return this.el.getAttribute(PHX_SESSION) || this.parent.getSession();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\n      if (this.hasGracefullyClosed()) {\n        this.log(\"destroyed\", function () {\n          return [\"the server view has gracefully closed\"];\n        });\n        callback();\n      } else {\n        this.log(\"destroyed\", function () {\n          return [\"the child has been removed from the parent\"];\n        });\n        this.channel.leave().receive(\"ok\", callback).receive(\"error\", callback).receive(\"timeout\", callback);\n      }\n    }\n  }, {\n    key: \"hideLoader\",\n    value: function hideLoader() {\n      clearTimeout(this.loaderTimer);\n      this.loader.style.display = \"none\";\n    }\n  }, {\n    key: \"showLoader\",\n    value: function showLoader() {\n      clearTimeout(this.loaderTimer);\n      this.el.classList = PHX_DISCONNECTED_CLASS;\n      this.loader.style.display = \"block\";\n      var middle = Math.floor(this.el.clientHeight / LOADER_ZOOM);\n      this.loader.style.top = \"-\" + middle + \"px\";\n    }\n  }, {\n    key: \"log\",\n    value: function log(kind, msgCallback) {\n      this.liveSocket.log(this, kind, msgCallback);\n    }\n  }, {\n    key: \"onJoin\",\n    value: function onJoin(_ref) {\n      var rendered = _ref.rendered;\n\n      this.log(\"join\", function () {\n        return [\"\", JSON.stringify(rendered)];\n      });\n      this.rendered = rendered;\n      this.hideLoader();\n      this.el.classList = PHX_CONNECTED_CLASS;\n      DOM.patch(this, this.el, this.id, Rendered.toString(this.rendered));\n      if (!this.hasBoundUI) {\n        this.bindUI();\n      }\n      this.hasBoundUI = true;\n      this.joinNewChildren();\n    }\n  }, {\n    key: \"joinNewChildren\",\n    value: function joinNewChildren() {\n      var _this7 = this;\n\n      var selector = PHX_VIEW_SELECTOR + \"[\" + PHX_PARENT_ID + \"=\\\"\" + this.id + \"\\\"]\";\n      document.querySelectorAll(selector).forEach(function (childEl) {\n        var child = _this7.liveSocket.getViewById(childEl.id);\n        if (!child) {\n          _this7.liveSocket.joinView(childEl, _this7);\n        }\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(diff) {\n      if (isEmpty(diff)) {\n        return;\n      }\n      this.log(\"update\", function () {\n        return [\"\", JSON.stringify(diff)];\n      });\n      this.rendered = Rendered.mergeDiff(this.rendered, diff);\n      var html = Rendered.toString(this.rendered);\n      this.newChildrenAdded = false;\n      DOM.patch(this, this.el, this.id, html);\n      if (this.newChildrenAdded) {\n        this.joinNewChildren();\n      }\n    }\n  }, {\n    key: \"onNewChildAdded\",\n    value: function onNewChildAdded(el) {\n      this.newChildrenAdded = true;\n    }\n  }, {\n    key: \"bindChannel\",\n    value: function bindChannel() {\n      var _this8 = this;\n\n      this.channel.on(\"render\", function (diff) {\n        return _this8.update(diff);\n      });\n      this.channel.on(\"redirect\", function (_ref2) {\n        var to = _ref2.to,\n            flash = _ref2.flash;\n        return Browser.redirect(to, flash);\n      });\n      this.channel.on(\"session\", function (_ref3) {\n        var token = _ref3.token;\n        return _this8.el.setAttribute(PHX_SESSION, token);\n      });\n      this.channel.onError(function (reason) {\n        return _this8.onError(reason);\n      });\n      this.channel.onClose(function () {\n        return _this8.onGracefulClose();\n      });\n    }\n  }, {\n    key: \"onGracefulClose\",\n    value: function onGracefulClose() {\n      this.gracefullyClosed = true;\n      this.liveSocket.destroyViewById(this.id);\n    }\n  }, {\n    key: \"hasGracefullyClosed\",\n    value: function hasGracefullyClosed() {\n      return this.gracefullyClosed;\n    }\n  }, {\n    key: \"join\",\n    value: function join() {\n      var _this9 = this;\n\n      if (this.parent) {\n        this.parent.channel.onError(function () {\n          return _this9.channel.leave();\n        });\n      }\n      this.channel.join().receive(\"ok\", function (data) {\n        return _this9.onJoin(data);\n      }).receive(\"error\", function (resp) {\n        return _this9.onJoinError(resp);\n      });\n    }\n  }, {\n    key: \"onJoinError\",\n    value: function onJoinError(resp) {\n      this.displayError();\n      this.log(\"error\", function () {\n        return [\"unable to join\", resp];\n      });\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(reason) {\n      this.log(\"error\", function () {\n        return [\"view crashed\", reason];\n      });\n      this.liveSocket.onViewError(this);\n      document.activeElement.blur();\n      this.displayError();\n    }\n  }, {\n    key: \"displayError\",\n    value: function displayError() {\n      this.showLoader();\n      this.el.classList = PHX_DISCONNECTED_CLASS + \" \" + PHX_ERROR_CLASS;\n    }\n  }, {\n    key: \"pushWithReply\",\n    value: function pushWithReply(event, payload) {\n      var _this10 = this;\n\n      var onReply = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\n      this.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", function (diff) {\n        _this10.update(diff);\n        onReply();\n      });\n    }\n  }, {\n    key: \"pushClick\",\n    value: function pushClick(clickedEl, event, phxEvent) {\n      event.preventDefault();\n      var val = clickedEl.getAttribute(this.binding(\"value\")) || clickedEl.value || \"\";\n      this.pushWithReply(\"event\", {\n        type: \"click\",\n        event: phxEvent,\n        id: clickedEl.id,\n        value: val\n      });\n    }\n  }, {\n    key: \"pushKey\",\n    value: function pushKey(keyElement, kind, event, phxEvent) {\n      this.pushWithReply(\"event\", {\n        type: \"key\" + kind,\n        event: phxEvent,\n        id: event.target.id,\n        value: keyElement.value || event.key\n      });\n    }\n  }, {\n    key: \"pushInput\",\n    value: function pushInput(inputEl, event, phxEvent) {\n      this.pushWithReply(\"event\", {\n        type: \"form\",\n        event: phxEvent,\n        id: event.target.id,\n        value: this.serializeForm(inputEl.form)\n      });\n    }\n  }, {\n    key: \"pushFormSubmit\",\n    value: function pushFormSubmit(formEl, event, phxEvent, onReply) {\n      if (event) {\n        event.target.disabled = true;\n      }\n      this.pushWithReply(\"event\", {\n        type: \"form\",\n        event: phxEvent,\n        id: event && event.target.id || null,\n        value: this.serializeForm(formEl)\n      }, onReply);\n    }\n  }, {\n    key: \"eachChild\",\n    value: function eachChild(selector, each) {\n      var _this11 = this;\n\n      return this.el.querySelectorAll(selector).forEach(function (child) {\n        if (_this11.ownsElement(child)) {\n          each(child);\n        }\n      });\n    }\n  }, {\n    key: \"ownsElement\",\n    value: function ownsElement(element) {\n      return element.getAttribute(PHX_PARENT_ID) === this.id || maybe(element.closest(PHX_VIEW_SELECTOR), \"id\") === this.id;\n    }\n  }, {\n    key: \"bindUI\",\n    value: function bindUI() {\n      var _this12 = this;\n\n      this.bindForms();\n      this.eachChild(\"[\" + this.binding(\"click\") + \"]\", function (el) {\n        return _this12.bindClick(el);\n      });\n      this.eachChild(\"[\" + this.binding(\"keyup\") + \"]\", function (el) {\n        return _this12.bindKey(el, \"up\");\n      });\n      this.eachChild(\"[\" + this.binding(\"keydown\") + \"]\", function (el) {\n        return _this12.bindKey(el, \"down\");\n      });\n      this.eachChild(\"[\" + this.binding(\"keypress\") + \"]\", function (el) {\n        return _this12.bindKey(el, \"press\");\n      });\n    }\n  }, {\n    key: \"bindClick\",\n    value: function bindClick(el) {\n      var _this13 = this;\n\n      this.bindOwnAddedNode(el, el, this.binding(\"click\"), function (phxEvent) {\n        el.addEventListener(\"click\", function (e) {\n          return _this13.pushClick(el, e, phxEvent);\n        });\n      });\n    }\n  }, {\n    key: \"bindKey\",\n    value: function bindKey(el, kind) {\n      var _this14 = this;\n\n      var event = \"key\" + kind;\n      this.bindOwnAddedNode(el, el, this.binding(event), function (phxEvent) {\n        var phxTarget = _this14.target(el);\n        phxTarget.addEventListener(event, function (e) {\n          _this14.pushKey(el, kind, e, phxEvent);\n        });\n      });\n    }\n  }, {\n    key: \"bindForms\",\n    value: function bindForms() {\n      var _this15 = this;\n\n      var change = this.binding(\"change\");\n      this.eachChild(\"form[\" + change + \"] input\", function (input) {\n        _this15.bindChange(input);\n      });\n      this.eachChild(\"form[\" + change + \"] select\", function (input) {\n        _this15.bindChange(input);\n      });\n      this.eachChild(\"form[\" + change + \"] textarea\", function (textarea) {\n        _this15.bindChange(textarea);\n      });\n\n      var submit = this.binding(\"submit\");\n      this.eachChild(\"form[\" + submit + \"]\", function (form) {\n        _this15.bindSubmit(form);\n      });\n    }\n  }, {\n    key: \"bindChange\",\n    value: function bindChange(input) {\n      var _this16 = this;\n\n      this.onInput(input, function (phxEvent, e) {\n        if (DOM.isTextualInput(input)) {\n          input.setAttribute(PHX_HAS_FOCUSED, true);\n        } else {\n          _this16.liveSocket.setActiveElement(e.target);\n        }\n        _this16.pushInput(input, e, phxEvent);\n      });\n    }\n  }, {\n    key: \"bindSubmit\",\n    value: function bindSubmit(form) {\n      var _this17 = this;\n\n      this.bindOwnAddedNode(form, form, this.binding(\"submit\"), function (phxEvent) {\n        form.addEventListener(\"submit\", function (e) {\n          e.preventDefault();\n          _this17.submitForm(form, phxEvent, e);\n        });\n        _this17.scheduleSubmit(form, phxEvent);\n      });\n    }\n  }, {\n    key: \"submitForm\",\n    value: function submitForm(form, phxEvent, e) {\n      var _this18 = this;\n\n      form.setAttribute(PHX_HAS_SUBMITTED, \"true\");\n      DOM.disableForm(form, this.bindingPrefix);\n      this.liveSocket.blurActiveElement(this);\n      this.pushFormSubmit(form, e, phxEvent, function () {\n        DOM.restoreDisabledForm(form, _this18.bindingPrefix);\n        _this18.liveSocket.restorePreviouslyActiveFocus();\n      });\n    }\n  }, {\n    key: \"scheduleSubmit\",\n    value: function scheduleSubmit(form, phxEvent) {\n      var _this19 = this;\n\n      var everyMs = parseInt(form.getAttribute(this.binding(\"submit-every\")));\n      if (everyMs && this.el.contains(form)) {\n        setTimeout(function () {\n          _this19.submitForm(form, phxEvent);\n          _this19.scheduleSubmit(form, phxEvent);\n        }, everyMs);\n      }\n    }\n  }, {\n    key: \"maybeBindAddedNode\",\n    value: function maybeBindAddedNode(el) {\n      if (!el.getAttribute || !this.ownsElement(el)) {\n        return;\n      }\n\n      this.bindClick(el);\n      this.bindSubmit(el);\n      this.bindChange(el);\n      this.bindKey(el, \"up\");\n      this.bindKey(el, \"down\");\n      this.bindKey(el, \"press\");\n    }\n  }, {\n    key: \"binding\",\n    value: function binding(kind) {\n      return \"\" + this.bindingPrefix + kind;\n    }\n\n    // private\n\n  }, {\n    key: \"serializeForm\",\n    value: function serializeForm(form) {\n      return new URLSearchParams(new FormData(form)).toString();\n    }\n  }, {\n    key: \"bindOwnAddedNode\",\n    value: function bindOwnAddedNode(el, targetEl, event, callback) {\n      if (targetEl && !targetEl.getAttribute) {\n        return;\n      }\n      var phxEvent = targetEl.getAttribute(event);\n\n      if (phxEvent && !el.getAttribute(PHX_BOUND) && this.ownsElement(el)) {\n        el.setAttribute(PHX_BOUND, true);\n        callback(phxEvent);\n      }\n    }\n  }, {\n    key: \"onInput\",\n    value: function onInput(input, callback) {\n      if (!input.form) {\n        return;\n      }\n      this.bindOwnAddedNode(input, input.form, this.binding(\"change\"), function (phxEvent) {\n        var event = input.type === \"radio\" ? \"change\" : \"input\";\n        input.addEventListener(event, function (e) {\n          return callback(phxEvent, e);\n        });\n      });\n    }\n  }, {\n    key: \"target\",\n    value: function target(el) {\n      var target = el.getAttribute(this.binding(\"target\"));\n      if (target === \"window\") {\n        return window;\n      } else if (target === \"document\") {\n        return document;\n      } else if (target) {\n        return document.getElementById(target);\n      } else {\n        return el;\n      }\n    }\n  }]);\n\n  return View;\n}();\n\nexports.default = LiveSocket;\n\n//# sourceURL=webpack://phoenix_live_view/./js/phoenix_live_view.js?./node_modules/babel-loader/lib");

/***/ }),

/***/ "./node_modules/morphdom/dist/morphdom.js":
/*!************************************************!*\
  !*** ./node_modules/morphdom/dist/morphdom.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\n\nvar testEl = doc ?\n    doc.body || doc.createElement('div') :\n    {};\n\n// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>\n// (IE7+ support) <=IE7 does not support el.hasAttribute(name)\nvar actualHasAttributeNS;\n\nif (testEl.hasAttributeNS) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttributeNS(namespaceURI, name);\n    };\n} else if (testEl.hasAttribute) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttribute(name);\n    };\n} else {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.getAttributeNode(namespaceURI, name) != null;\n    };\n}\n\nvar hasAttributeNS = actualHasAttributeNS;\n\n\nfunction toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!hasAttributeNS(toNode, attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!hasAttributeNS(toNode, null, attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name, '');\n        }\n    }\n}\n\nvar specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!hasAttributeNS(toEl, null, 'value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!hasAttributeNS(toEl, null, 'multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                var nodeName = curChild.nodeName;\n                if (nodeName && nodeName.toUpperCase() === 'OPTION') {\n                    if (hasAttributeNS(curChild, null, 'selected')) {\n                        selectedIndex = i;\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                morphAttrs(fromEl, toEl);\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = getNodeKey(curToNodeChild);\n\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (curFromNodeChild.nextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's moving the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    morphEl(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                                }\n\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    }\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        morphEl(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphEl(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nmodule.exports = morphdom;\n\n\n//# sourceURL=webpack://phoenix_live_view/./node_modules/morphdom/dist/morphdom.js?");

/***/ })

/******/ });
});